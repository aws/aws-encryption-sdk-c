module state_machine where

import type_def
import transition_function
    

// Translation of the the work inside the switch statement of the aws_cryptosdk_session_process function of session.c 
//(lines 185 - 240)
// Currently, transitions from ST_CONFIG, ST_WRITE_HEADER and ST_ENCRYPT_BODY are modeled. 
// All other states are assumed to just transition to the next subsequent state (even ST_DONE and ST_ERROR), even 
//though this is not necessarily accurate.

processState : current_state -> current_state
processState state_old = 
    if (state_old.sess.state == ST_CONFIG) && (state_old.sess.mode == 0) then 
        { sess = 
            {output_size_estimate = state_old.sess.output_size_estimate
            , input_size_estimate = state_old.sess.input_size_estimate 
            , header_size = state_old.sess.header_size
            , state = ST_GEN_KEY
            , mode = state_old.sess.mode
            , precise_size = state_old.sess.precise_size
            , data_so_far = state_old.sess.data_so_far
            , frame_size = state_old.sess.frame_size
            , precise_size_known = state_old.sess.precise_size_known
            , alg_prop = state_old.sess.alg_prop
            , header = state_old.sess.header
            }
        , output_buffer = state_old.output_buffer
        , input_buffer = state_old.input_buffer
        }
    else if state_old.sess.state == ST_CHECK_TRAILER then 
        {sess = 
            {output_size_estimate = state_old.sess.output_size_estimate
            , input_size_estimate = state_old.sess.input_size_estimate
            , header_size = state_old.sess.header_size
            , state = ST_DONE
            , mode = state_old.sess.mode
            , precise_size = state_old.sess.precise_size
            , data_so_far = state_old.sess.data_so_far
            , frame_size = state_old.sess.frame_size
            , precise_size_known = state_old.sess.precise_size_known
            , alg_prop = state_old.sess.alg_prop
            , header = state_old.sess.header
            }
        , output_buffer = state_old.output_buffer
        , input_buffer = state_old.input_buffer 
        }
    else if state_old.sess.state == ST_WRITE_HEADER then writeHeader state_old
    else if state_old.sess.state == ST_ENCRYPT_BODY then encryptBody state_old
    else 
        {sess = 
            {output_size_estimate = state_old.sess.output_size_estimate
            , input_size_estimate = state_old.sess.input_size_estimate
            , header_size = state_old.sess.header_size
            , state = state_old.sess.state + 1 //NOTE: this is inaccurate in the case of ST_DONE and ST_ERROR
            , mode = state_old.sess.mode
            , precise_size = state_old.sess.precise_size
            , data_so_far = state_old.sess.data_so_far
            , frame_size = state_old.sess.frame_size
            , precise_size_known = state_old.sess.precise_size_known
            , alg_prop = state_old.sess.alg_prop
            , header = state_old.sess.header
            }
        , output_buffer = state_old.output_buffer
        , input_buffer = state_old.input_buffer 
        }


// Function to determine is progress has been made after a call of processState (line 242 of session.c)

cmpState : current_state -> current_state -> Bit
cmpState state_new state_old = 
    if state_new.sess.state != state_old.sess.state then True
    else if state_new.output_buffer.ptr != state_old.output_buffer.ptr then True 
    else if state_new.input_buffer.ptr != state_old.input_buffer.ptr then True
    else False 

// Function to determine if a need for larger output or input buffers has been detected. 

bufferUpdated : current_state -> Bit 
bufferUpdated state_new = 
    if state_new.sess.output_size_estimate > state_new.output_buffer.len then True 
    else if state_new.sess.input_size_estimate > state_new.input_buffer.len then True 
    else False


// Function that determines if the loop can continue (line 243 of session.c)
// Assumption is that AWS_OP_SUCCESS has been returned. 

property loopContinues x = ( cmpState (processState x) x == True )

// Function that determines if either the loop continues or if a need for larger buffers has been detected. 

property progressMade x = ( cmpState (processState x) x == True ) || ( bufferUpdated  (processState x) == True )

//Function to generate new input/output buffers based on the input and output size estimates 

getNewBufferSize : [32] -> [32] -> [32]
getNewBufferSize old_size estimate_size = 
    if estimate_size > old_size then estimate_size
    else old_size

updateBuffers : current_state -> current_state
updateBuffers old_state = {sess = old_state.sess
                           , output_buffer = { ptr = old_state.output_buffer.ptr
                                              , len = getNewBufferSize old_state.output_buffer.len 
                                              old_state.sess.output_size_estimate
                                              }
                           , input_buffer = {ptr = old_state.input_buffer.ptr
                                            , len = getNewBufferSize old_state.input_buffer.len 
                                            old_state.sess.input_size_estimate 
                                            }
                           }
