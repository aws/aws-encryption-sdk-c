module transition_function where

import type_def
import helper_functions

// Cryptol translation of function try_write_header in session_encrypt.c (line 219 - 236)

writeHeader : current_state -> current_state
writeHeader state_old = 
    if state_old.output_buffer.len >= state_old.sess.header_size then 
        {sess = ( updateOutputInputEstimates ( advanceStateOnly state_old.sess ST_ENCRYPT_BODY) 
                                state_old.sess.header_size state_old.sess.input_size_estimate )
        , output_buffer = output_buffer_new_success 
        , input_buffer = state_old.input_buffer
        }
            where output_buffer_new_success = {ptr = state_old.output_buffer.ptr + state_old.sess.header_size
                            , len = state_old.output_buffer.len - state_old.sess.header_size
                            }
    else {sess = updateOutputInputEstimates state_old.sess state_old.sess.header_size 
                                                            state_old.sess.input_size_estimate
        , output_buffer = state_old.output_buffer
        , input_buffer = state_old.input_buffer
        }


// Cryptol translation of function try_parse_header in session_decrypt.c (line 156 - 191)

getHeaderSize : current_state -> [32]
getHeaderSize state_old = 
    if ( state_old.sess.header.aad_len_total > 0 ) then 
        (18 + MESSAGE_ID_LEN + state_old.sess.header.aad_len_total + state_old.sess.header.edk_len_total)
    else (20 + MESSAGE_ID_LEN + state_old.sess.header.aad_len_total + state_old.sess.header.edk_len_total)

updateInputBuffer : current_state -> [32]
updateInputBuffer state_old = 
    if ( state_old.sess.input_size_estimate < state_old.input_buffer.len ) then 
        if ( (state_old.input_buffer.len + 128) < state_old.input_buffer.len ) then ( SIZE_T - 1 )
        else  (state_old.input_buffer.len + 128)
    else state_old.sess.input_size_estimate


parseHeader : current_state -> current_state 
parseHeader state_old = 
    if (state_old.input_buffer.len < ( getHeaderSize state_old ) ) then {sess = updateOutputInputEstimates 
                                                                    state_old.sess 0 ( updateInputBuffer state_old )
                                                                        , output_buffer = state_old.output_buffer
                                                                        , input_buffer = state_old.input_buffer
                                                                        }

    else { sess = advanceStateOnly state_old.sess ST_UNWRAP_KEY
        , output_buffer = state_old.output_buffer
        , input_buffer = { ptr = state_old.input_buffer.ptr + ( getHeaderSize state_old )
                        , len = state_old.output_buffer.ptr - ( getHeaderSize state_old )
                        }
        }
    

// Cryptol translation of function try_encrypt_body in session_encrypt.c (line 238 - 333)


encryptHelper : current_state -> [32] -> [32] -> [4] -> current_state 
encryptHelper state_old size_in size_out new_state = 
    if ( state_old.input_buffer.len < size_in ) || ( state_old.output_buffer.len < size_out ) then 
        { sess = updateOutputInputEstimates state_old.sess size_out size_in 
        , output_buffer = state_old.output_buffer
        , input_buffer = state_old.input_buffer
        }
    else { sess = updateOutputInputEstimates (advanceStateOnly state_old.sess new_state) size_out size_in
                , output_buffer = { ptr = state_old.output_buffer.ptr + size_out
                                    , len = state_old.output_buffer.len - size_out
                                    }
                , input_buffer = { ptr = state_old.input_buffer.ptr + size_in
                                    , len = state_old.input_buffer.len - size_in
                                    }       
        }

encryptBodyFramed : current_state -> current_state
encryptBodyFramed state_old = 
    if ( state_old.sess.precise_size_known == 1 ) && (state_old.sess.precise_size - state_old.sess.data_so_far < 
    state_old.sess.frame_size) then 
        encryptHelper state_old (state_old.sess.precise_size - state_old.sess.data_so_far) (8 + 
        state_old.sess.alg_prop.iv_len + 4 + state_old.sess.precise_size - state_old.sess.data_so_far + 
        state_old.sess.alg_prop.tag_len) ST_WRITE_TRAILER
    else encryptHelper state_old state_old.sess.frame_size (4 + state_old.sess.alg_prop.iv_len + 
    state_old.sess.frame_size + state_old.sess.alg_prop.tag_len) ST_ENCRYPT_BODY

encryptBodyUnframed : current_state -> current_state
encryptBodyUnframed state_old = 
    if ( state_old.sess.precise_size_known == 1 ) then encryptHelper state_old state_old.sess.precise_size (
    state_old.sess.alg_prop.iv_len + 8 + state_old.sess.precise_size + state_old.sess.alg_prop.tag_len) 
    ST_WRITE_TRAILER
    else { sess = updateOutputInputEstimates state_old.sess 0 0 
            , output_buffer = state_old.output_buffer
            , input_buffer = state_old.input_buffer 
        }

encryptBody : current_state -> current_state
encryptBody state_old = 
    if state_old.sess.frame_size > 0 then encryptBodyFramed state_old
    else encryptBodyUnframed state_old
        

// Partial Cryptol translation of function try_decrypt_body in session_decrypt.c (line 193 - 252)

decryptHelper : current_state -> [32] -> [32] -> [4] -> current_state
decryptHelper state_old size_in size_out new_state = 
    if ( state_old.input_buffer.len < size_in ) || ( state_old.output_buffer.len < size_out ) then 
        { sess = updateOutputInputEstimates state_old.sess size_out size_in 
        , output_buffer = state_old.output_buffer
        , input_buffer = state_old.input_buffer
        }
    else { sess = updateOutputInputEstimates (advanceStateOnly state_old.sess new_state) size_out size_in
                , output_buffer = { ptr = state_old.output_buffer.ptr + size_out
                                    , len = state_old.output_buffer.len - size_out
                                    }
                , input_buffer = { ptr = state_old.input_buffer.ptr + size_in
                                    , len = state_old.input_buffer.len - size_in
                                    }       
        }

//TODO: Size of the unframed data is stored in the ciphertext (input_buffer). What is the best way to model this?
//TODO: Should not be using state_old.sess.precise_size. This is only temporary. 
decryptBodyUnframed : current_state -> current_state 
decryptBodyUnframed state_old = decryptHelper state_old ( state_old.sess.alg_prop.iv_len + 8 + 
state_old.sess.precise_size + state_old.sess.alg_prop.tag_len)   state_old.sess.precise_size ST_CHECK_TRAILER

//TODO: Whether the frame is final as well as the size of the final frame is stored in the ciphertext (input_buffer). 

decryptBodyFramed : current_state -> current_state 
decryptBodyFramed state_old = state_old 

decryptBody : current_state -> current_state 
decryptBody state_old = 
    if ( state_old.sess.frame_size > 0 ) then decryptBodyUnframed state_old
    else decryptBodyUnframed state_old


