module type_def where


// Compound type that stores all the variables that determine if the loop in the aws_cryptosdk_session_process function of session.c has made progress (line 242)
type current_state = {sess : session
                      , output_buffer : aws_byte_cursor
                      , input_buffer : aws_byte_cursor
                      }


// TODO: size of the output_size_estimate, input_size_estimate, header_size fields. 32-bit integers too large?
// TODO: session type is not currently complete. Only has the fields necessary for current proofs. 
// See <aws/cryptosdk/private/session.h>: 50 - 82 

type session = {
    output_size_estimate : [32] 
    , input_size_estimate : [32]
    , header_size : [32]
    , state : [4] 
    , mode : [1] //do we encrypt (0) or decrypt (1) 
    , precise_size : [32]
    , data_so_far : [32]
    , frame_size : [32] // if frame size is zero, the message is unframed
    , precise_size_known : [1]
    , alg_prop : alg_properties 
    , header : hdr
    }

// See <aws/common/byte_buf.h>: 43 - 46 

type aws_byte_cursor = {
    ptr : [32] //NOTE: actual size in the c code is [8]. This is to add other fields (such as header size with ease)
    , len : [32]
    }

// <aws/cryptosdk/cipher.h>> : 28 - 41

type alg_properties = {
    iv_len : [32]
    , tag_len : [32]
}

// <aws/cryptosdk/private/header.h>: 32 - 49
// Very over-simplified. Currently multiple fields are concatenated. 
type hdr = {
    aad_len_total : [32]
    , edk_len_total : [32]
}

// <aws/cryptosdk/private/header.h>: 16
MESSAGE_ID_LEN = 16 

// enum of states in the session.c state machine 
// See <aws/cryptosdk/private/session.h>: 26 - 48 

ST_CONFIG = 0

// Decrypt path 

ST_READ_HEADER = 1
ST_UNWRAP_KEY = 2
ST_DECRYPT_BODY = 3
ST_CHECK_TRAILER = 4

// Encrypt path 

ST_GEN_KEY = 5
ST_WRITE_HEADER = 6
ST_ENCRYPT_BODY = 7
ST_WRITE_TRAILER = 8


ST_DONE = 9
ST_ERROR = 10


// <aws/cryptosdk/private/session.h>: 23- 24
DEFAULT_FRAME_SIZE = 256 * 1024
MAX_FRAME_SIZE = 4294967295


SIZE_T = 4294967295 //because I used 32 bit integers. Can be updated. 
