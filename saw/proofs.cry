


module proofs where 

import type_def
import state_machine

/* In this file, a set of state machine properties are specified. 
These properties can be proven using SAW configured with some satisfiability solver. 
In all properties, progress is considered from any non-error and non-done state.
*/



// Are known preconditons about the fields of the state are met. 
arePreconditionsMet : current_state -> Bit
arePreconditionsMet current_state = 
    if current_state.sess.data_so_far > current_state.sess.precise_size then False //SANITY CHECK
    else if current_state.sess.frame_size >= MAX_FRAME_SIZE then False             //SANITY CHECK
    else if current_state.sess.state >=ST_DONE then False                          //SANITY CHECK
    else if current_state.sess.alg_prop.iv_len != 96 then False                    //ACCORDING TO DOC
    else if current_state.sess.alg_prop.tag_len != 128 then False                  //ACCORDING TO DOC
    else True 


// Is progress made for any arbitrary state.
isProgressMade : current_state -> Bit
isProgressMade state = 
    if ~arePreconditionsMet state then False
    else ~isProgressMadeProperty state


// Does the loop continues for any arbitrary state.
doesLoopContinue : current_state -> Bit
doesLoopContinue state = 
    if ~arePreconditionsMet state then False
    else ~doesLoopContinueProperty state


// Is progress made for any arbitrary state when the precise size is known.
isProgressMadeSizeKnown : current_state -> Bit
isProgressMadeSizeKnown state = 
    if ~arePreconditionsMet state then False
    else if state.sess.precise_size_known == 0 then False
    else ~isProgressMadeProperty state


// Does the loop continues for any arbitrary state when the precise size is known. 
doesLoopContinueSizeKnown : current_state -> Bit
doesLoopContinueSizeKnown state = 
    if ~arePreconditionsMet state then False
    else if state.sess.precise_size_known == 0 then False
    else ~doesLoopContinueProperty state


// Does the loop continues after 1 update of the input/output buffers for the ST_WRITE_HEADER state?
// Here an update means the size of the buffers has been increased to the input/output size estimates. 
doesWriteHeaderContinueAfterUpdate : current_state -> Bit
doesWriteHeaderContinueAfterUpdate state = 
    if ~arePreconditionsMet state then False
    else if state.sess.state != ST_WRITE_HEADER then False 
    else  ~doesLoopContinueProperty ( updateBuffers (processState state) ) && (~doesLoopContinueProperty state)

// Does loop continues after 1 update of the input/output buffers for the ST_ENCRYPT_BODY state.  
// Here an update means the size of the buffers has been increased to the input/output size estimates. 
// We do not assume the precise size is known 
doesEncryptBodyContinueAfterUpdate : current_state -> Bit
doesEncryptBodyContinueAfterUpdate state = 
    if ~arePreconditionsMet state then False
    else if state.sess.state != ST_ENCRYPT_BODY then False 
    else  ~doesLoopContinueProperty ( updateBuffers (processState state) ) && (~doesLoopContinueProperty state)


// Does loop continues after 1 update of the input/output buffers for the ST_ENCRYPT_BODY state.  
// Here an update means the size of the buffers has been increased to the input/output size estimates. 
// We assume the precise size is known 
doesEncryptBodyContinueAfterUpdateSizeKnown : current_state -> Bit
doesEncryptBodyContinueAfterUpdateSizeKnown state = 
    if ~arePreconditionsMet state then False
    else if state.sess.precise_size_known == 0 then False 
    else if state.sess.state != ST_ENCRYPT_BODY then False 
    else  ~doesLoopContinueProperty ( updateBuffers (processState state) ) && (~doesLoopContinueProperty state)


