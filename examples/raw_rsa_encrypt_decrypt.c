/*
 * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <aws/common/string.h>
#include <aws/cryptosdk/default_cmm.h>
#include <aws/cryptosdk/raw_rsa_keyring.h>
#include <aws/cryptosdk/session.h>
#include <stdio.h>

#define BUFFER_SIZE 4096

/* Encrypts/decrypts the entire input buffer using the CMM provided. */
void encrypt_or_decrypt(
    struct aws_allocator *alloc,
    struct aws_cryptosdk_cmm *cmm,
    enum aws_cryptosdk_mode mode,
    uint8_t *output,
    size_t output_buf_sz,
    size_t *output_len,
    const uint8_t *input,
    size_t input_len) {
    struct aws_cryptosdk_session *session = aws_cryptosdk_session_new_from_cmm(alloc, mode, cmm);
    assert(session);

    if (mode == AWS_CRYPTOSDK_ENCRYPT) {
        assert(AWS_OP_SUCCESS == aws_cryptosdk_session_set_message_size(session, input_len));
    }

    size_t input_consumed;
    assert(
        AWS_OP_SUCCESS ==
        aws_cryptosdk_session_process(session, output, output_buf_sz, output_len, input, input_len, &input_consumed));
    assert(aws_cryptosdk_session_is_done(session));
    assert(input_consumed == input_len);
    aws_cryptosdk_session_destroy(session);
}

char *read_file_into_buffer(const char *filename) {
    FILE *fp = fopen(filename, "rb");
    if (!fp) return NULL;

    fseek(fp, 0L, SEEK_END);
    size_t sz = ftell(fp);
    rewind(fp);

    char *data = (char *)malloc(sz + 1);
    if (data) {
        data[sz] = '\0';
        if (sz != fread(data, 1, sz, fp)) {
            free(data);
            data = NULL;
        }
    }
    fclose(fp);
    return data;
}

/* This example does a simple string encryption using the raw RSA keyring.
 * This keyring does local encryption of data keys using a wrapping key
 * (i.e., master key) provided as an RSA public key PEM file, and/or
 * local decryption of data keys using a wrapping key provided as an RSA
 * private key PEM file. The RSA encryption can be done with a variety
 * of padding modes. See cipher.h for the list of support padding modes.
 *
 * The raw RSA keyring does the equivalent encryption and decryption as the
 * AWS Encryption SDK for Java's JceMasterKey when used with a private and
 * public key pair and the AWS Encryption SDK for Python's RawMasterKey when
 * used in asymmetric mode. Data encrypted by any of the SDKs can be decrypted
 * by any of the others using the same wrapping key.
 */
int main(int argc, char **argv) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s private_key_pem public_key_pem\n", argv[0]);
        return 1;
    }

    char *public_key_pem = read_file_into_buffer(argv[2]);
    if (!public_key_pem) {
        fprintf(stderr, "Error reading public key PEM file.\n");
        return 2;
    }

    char *private_key_pem = read_file_into_buffer(argv[1]);
    if (!private_key_pem) {
        fprintf(stderr, "Error reading private key PEM file.\n");
        free(public_key_pem);
        return 3;
    }

    struct aws_allocator *alloc = aws_default_allocator();

    /* See the comments in the raw_aes_encrypt_decrypt.c example for details
     * on wrapping key namespaces and names.
     */
    AWS_STATIC_STRING_FROM_LITERAL(wrapping_key_namespace, "my master keys");
    AWS_STATIC_STRING_FROM_LITERAL(wrapping_key_name, "key #2");

    /* We create a raw RSA keyring capable of encryption and decryption by
     * giving it a private key and public key pair in PEM format. Alternatively,
     * you may create a raw RSA keyring with only one of the PEM files by
     * setting the other parameter to NULL, but then that keyring will
     * only be capable of either encryption or decryption.
     *
     * In order for an RSA keyring to properly decrypt data encrypted by
     * another RSA keyring, all of the following must be true:
     *
     * (1) The two keyrings' wrapping key namespaces are identical.
     * (2) The two keyrings' wrapping key names are identical.
     * (3) The public key used by the encrypting keyring was derived from
     *     the private key used by the decrypting keyring.
     * (4) Both keyrings are set to the same padding mode.
     *
     * The last point is important. The data format of the encrypted data keys
     * generated by the raw RSA keyring does not store the padding mode used,
     * so the AWS Encryption SDK cannot detect the padding mode on decrypt.
     * It must be manually configured before decryption to the same mode that
     * was used on encryption.
     */
    struct aws_cryptosdk_keyring *keyring = aws_cryptosdk_raw_rsa_keyring_new(
        alloc, wrapping_key_namespace, wrapping_key_name, private_key_pem, public_key_pem, AWS_CRYPTOSDK_RSA_PKCS1);
    assert(keyring);

    /* The raw RSA keyring keeps its own copies of the PEM files, so we free
     * our own buffers, but first we zero out the bytes of the private key.
     */
    aws_secure_zero(private_key_pem, strlen(private_key_pem));
    free(private_key_pem);
    free(public_key_pem);

    /* We create a default Cryptographic Materials Manager (CMM) using this keyring. */
    struct aws_cryptosdk_cmm *cmm = aws_cryptosdk_default_cmm_new(alloc, keyring);
    assert(cmm);

    /* We release the pointer on the keyring so that it will be destroyed when the
     * CMM is destroyed. The CMM will be used for both encrypt and decrypt.
     */
    aws_cryptosdk_keyring_release(keyring);

    const char *plaintext_original      = "Hello world!";
    const size_t plaintext_original_len = strlen(plaintext_original);

    uint8_t ciphertext[BUFFER_SIZE];
    uint8_t plaintext_result[BUFFER_SIZE];
    size_t ciphertext_len;
    size_t plaintext_result_len;

    encrypt_or_decrypt(
        alloc,
        cmm,
        AWS_CRYPTOSDK_ENCRYPT,
        ciphertext,
        BUFFER_SIZE,
        &ciphertext_len,
        (const uint8_t *)plaintext_original,
        plaintext_original_len);
    printf(">> Encrypted to ciphertext of length %zu\n", ciphertext_len);

    encrypt_or_decrypt(
        alloc,
        cmm,
        AWS_CRYPTOSDK_DECRYPT,
        plaintext_result,
        BUFFER_SIZE,
        &plaintext_result_len,
        ciphertext,
        ciphertext_len);
    printf(">> Decrypted to plaintext of length %zu\n", plaintext_result_len);

    assert(plaintext_original_len == plaintext_result_len);
    assert(!memcmp(plaintext_original, plaintext_result, plaintext_result_len));
    printf(">> Decrypted plaintext matches original!\n");

    /* Releasing the CMM causes both the CMM and keyring to be destroyed.
     * The destruction of the raw RSA keyring also causes the internal copy
     * of the private key to be securely zeroed before deallocation.
     */
    aws_cryptosdk_cmm_release(cmm);

    return 0;
}
